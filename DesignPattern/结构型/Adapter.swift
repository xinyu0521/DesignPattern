//
//  Adapter.swift
//  DesignPattern
//
//  Created by zhanx630 on 2021/11/19.
//

/// 适配器模式的英文翻译是 Adapter Design Pattern
/// 顾名思义，这个模式就是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。
/// 应用场景：
/// 1.封装有缺陷的接口设计
/// 2.统一多个类的接口设计
/// 3.替换依赖的外部系统
/// 4.兼容老版本接口
/// 5.适配不同格式的数据

protocol Target {
    func f1()
    func f2()
    func fc()
}

class Adaptee {
    func fa() {}
    func fb() {}
    func fc() {}
}

// 类适配器，基于继承
class Adapter: Adaptee, Target {
    func f1() {
        super.fa()
    }

    func f2() {
        // 重新实现f2
    }

    // fc() 继承自父类不需实现
}

// 对象适配器，基于组合
class Adapter2: Target {
    let adaptee: Adaptee

    init(_ adaptee: Adaptee) {
        self.adaptee = adaptee
    }

    func f1() {
        adaptee.fa()
    }

    func f2() {
        // ...
    }

    func fc() {
        adaptee.fc()
    }
}

/// 代理、桥接、装饰器、适配器 4 种设计模式的区别
/// 代理、桥接、装饰器、适配器，这 4 种模式是比较常用的结构型设计模式。它们的代码结构非常相似。笼统来说，它们都可以称为 Wrapper 模式，也就是通过 Wrapper 类二次封装原始类。
/// 尽管代码结构相似，但这 4 种设计模式的用意完全不同，也就是说要解决的问题、应用场景不同，这也是它们的主要区别。这里我就简单说一下它们之间的区别。
/// 代理模式：代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。
/// 桥接模式：桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。
/// 装饰器模式：装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。
/// 适配器模式：适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。
